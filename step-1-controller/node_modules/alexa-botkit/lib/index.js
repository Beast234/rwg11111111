'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _botkit = require('botkit');

var _express = require('express');

var _express2 = _interopRequireDefault(_express);

var _bodyParser = require('body-parser');

var _bodyParser2 = _interopRequireDefault(_bodyParser);

var _alexaResponse = require('alexa-response');

var _alexaResponse2 = _interopRequireDefault(_alexaResponse);

var _alexaReq = require('alexa-req');

var _alexaReq2 = _interopRequireDefault(_alexaReq);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var AlexaBot = function AlexaBot(configuration) {
  // Create a core botkit bot
  var alexaBot = (0, _botkit.core)(configuration || {});

  // customize the bot definition, which will be used when new connections
  // spawn!
  alexaBot.defineBot(function (botkit, config) {
    var bot = {
      type: 'alexa',
      botkit: botkit,
      config: config || {},
      utterances: botkit.utterances
    };

    bot.startConversation = function (message, cb) {
      botkit.startConversation(undefined, message, cb);
    };

    bot.createConversation = function (message, cb) {
      botkit.createConversation(undefined, message, cb);
    };

    bot.findConversation = function (message, cb) {
      botkit.debug('CUSTOM FIND CONVO', message.user, message.channel);
      /* eslint-disable no-plusplus */
      for (var t = 0; t < botkit.tasks.length; t++) {
        for (var c = 0; c < botkit.tasks[t].convos.length; c++) {
          var con = botkit.tasks[t].convos[c];
          if (con.isActive() && con.source_message.user === message.user) {
            botkit.debug('FOUND EXISTING CONVO!');
            cb(botkit.tasks[t].convos[c]);
            return;
          }
        }
        /* eslint-enable */
      }
      cb();
    };

    bot.send = function (message) {
      var resp = message.resp;

      var isString = typeof resp === 'string';
      message.src.response.send((isString && _alexaResponse2.default.say(resp) || resp).build());
    };

    bot.reply = function (src, resp, cb) {
      var msg = { src: src, resp: resp };

      bot.say(msg, cb);
    };

    return bot;
  });

  // set up a web route for receiving incoming requests from alexa
  alexaBot.createWebhookEndpoints = function (webserver, bot) {
    // notify the user that the webhook is running
    alexaBot.log('** Serving webhook endpoint for Alexa Platform at: http://' + alexaBot.config.hostname + ':' + alexaBot.config.port + '/alexa/receive');
    webserver.post('/alexa/receive', function (req, res) {
      alexaBot.debug('GOT A MESSAGE HOOK');

      // parse the request from alexa
      var alexa = new _alexaReq2.default(req.body);
      var message = {
        text: alexa.getIntentName(),
        user: alexa.getUserId(),
        channel: alexa.getUserId(),
        timestamp: alexa.getTimeStamp(),
        response: res,
        alexa: alexa
      };

      // notify botkit we received a message
      alexaBot.receiveMessage(bot, message);
    });

    return alexaBot;
  };

  alexaBot.setupWebserver = function (port, cb) {
    if (!port) {
      throw new Error('Cannot start webserver without a port');
    }

    alexaBot.config.port = port;

    alexaBot.webserver = (0, _express2.default)();
    alexaBot.webserver.use(_bodyParser2.default.json());
    alexaBot.webserver.use(_bodyParser2.default.urlencoded({ extended: true }));

    alexaBot.webserver.listen(alexaBot.config.port, alexaBot.config.hostname, function () {
      alexaBot.log('** Starting Alexa webserver on port ' + alexaBot.config.port);
      if (cb) {
        cb(null, alexaBot.webserver);
      }
    });

    return alexaBot;
  };

  return alexaBot;
};

exports.default = AlexaBot;
module.exports = exports['default'];