'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function chainable(validator) {
  var chainableValidator = function chainableValidator(props, propName, tagName) {
    return validator(props, propName, tagName);
  };

  chainableValidator.isRequired = function (props, propName, tagName) {
    if (!props || !props[propName]) {
      throw new Error('Missing required prop "' + propName + '" on "' + tagName + '" tag.');
    } else {
      return validator(props, propName, tagName);
    }
  };

  return chainableValidator;
}

var _oneOf = function _oneOf() {
  var possibilities = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  return function (props, propName, tagName) {
    var value = props && props[propName];
    if (value && possibilities.indexOf(value) < 0) {
      throw new Error('Unsupported value "' + value + '" for prop "' + propName + '" on "' + tagName + '" tag. Supported values are: ' + possibilities.join(', ') + '.');
    }
  };
};

var _match = function _match(regex) {
  return function (props, propName, tagName) {
    var value = props && props[propName];
    if (value && !regex.exec(value)) {
      throw new Error('Invalid value for prop "' + propName + '" on "' + tagName + '" tag. Expected "' + value + '" to match ' + regex.toString() + '.');
    }
  };
};

var array = function array(props, propName, tagName) {
  var value = props && props[propName];
  if (!Array.isArray(value)) {
    throw new Error('Invalid value for prop "' + propName + '" on "' + tagName + '" tag. Expected an array.');
  }
};

var none = function none(props, propName, tagName) {
  if (props && props[propName]) {
    throw new Error('Unexpected prop "' + propName + '" on "' + tagName + '" tag. Expected none.');
  }
};

var PropTypes = {
  array: chainable(array),
  match: function match(regex) {
    return chainable(_match(regex));
  },
  none: chainable(none),
  oneOf: function oneOf(possibilities) {
    return chainable(_oneOf(possibilities));
  }
};

/**
 * Represents a pause in the speech. Set the length of the pause with the strength or time attributes.
 * More info: https://www.w3.org/TR/speech-synthesis/#S3.2.3
 */

var Strengths = ['none', // No pause should be outputted. This can be used to remove a pause that would normally occur (such as after a period).
'x-weak', // No pause should be outputted (same as none).
'weak', // Treat adjacent words as if separated by a single comma (equivalent to medium).
'medium', // Treat adjacent words as if separated by a single comma.
'strong', // Make a sentence break (equivalent to using the <s> tag).
'x-strong' // Make a paragraph break (equivalent to using the <p> tag).
];

var breakTag = {
  type: 'break',
  propTypes: {
    strength: PropTypes.oneOf(Strengths),
    time: PropTypes.match(/(\d+)(m?s)?/),
    children: PropTypes.none
  }
};

/**
 * Represents a paragraph. This tag provides extra-strong breaks before and after the tag.
 * More info: https://www.w3.org/TR/speech-synthesis/#S3.1.7
 */

var p = {
  type: 'p',
  propTypes: {
    children: PropTypes.array.isRequired
  }
};

/**
 * Represents a sentence. This tag provides strong breaks before and after the tag.
 * More info: https://www.w3.org/TR/speech-synthesis/#S3.1.7
 */

var s = {
  type: 's',
  propTypes: {
    children: PropTypes.array.isRequired
  }
};

/**
 * Indicate information on the type of text construct contained within the element.
 * More info: https://www.w3.org/TR/speech-synthesis/#S3.1.8
 */

var interpretations = ['characters', 'spell-out', // Spell out each letter
'cardinal', 'number', // Interpret the value as a cardinal number
'ordinal', // Interpret the value as an ordinal number
'digits', // Spell each digit separately
'fraction', // Interpret the value as a fraction
'unit', // Interpret a value as a measurement
'date', // Interpret the value as a date. Specify the format with the format attribute
'time', // Interpret a value such as 1'21" as duration in minutes and seconds
'telephone', // Interpret a value as a 7-digit or 10-digit telephone number
'address' // Interpret a value as part of street address
];

var formats = ['mdy', 'dmy', 'ymd', 'md', 'dm', 'ym', 'my', 'd', 'm', 'y'];

var sayAsTag = {
  type: 'say-as',
  propTypes: {
    children: PropTypes.array.isRequired,
    'interpret-as': PropTypes.oneOf(interpretations).isRequired,
    format: function format(props, propName, tagName) {
      if (props['interpret-as'] === 'date') {
        var format = PropTypes.oneOf(formats).isRequired;
        return format(props, propName, tagName);
      }
    }
  }
};

/**
 * This is the root element of an SSML document.
 * More info: https://www.w3.org/TR/speech-synthesis/#S3.1.1
 */

var speak = {
  type: 'speak',
  propTypes: {
    children: PropTypes.array.isRequired
  }
};

var schema = {
  'break': breakTag,
  p: p,
  s: s,
  'say-as': sayAsTag,
  speak: speak
};

var validate = (function (_ref, props) {
  var name = _ref.name,
      _ref$propTypes = _ref.propTypes,
      propTypes = _ref$propTypes === undefined ? {} : _ref$propTypes;

  Object.keys(propTypes).forEach(function (key) {
    var validator = propTypes[key];
    validator && validator(props, key, name);
  });

  return props;
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};





var asyncGenerator = function () {
  function AwaitValue(value) {
    this.value = value;
  }

  function AsyncGenerator(gen) {
    var front, back;

    function send(key, arg) {
      return new Promise(function (resolve, reject) {
        var request = {
          key: key,
          arg: arg,
          resolve: resolve,
          reject: reject,
          next: null
        };

        if (back) {
          back = back.next = request;
        } else {
          front = back = request;
          resume(key, arg);
        }
      });
    }

    function resume(key, arg) {
      try {
        var result = gen[key](arg);
        var value = result.value;

        if (value instanceof AwaitValue) {
          Promise.resolve(value.value).then(function (arg) {
            resume("next", arg);
          }, function (arg) {
            resume("throw", arg);
          });
        } else {
          settle(result.done ? "return" : "normal", result.value);
        }
      } catch (err) {
        settle("throw", err);
      }
    }

    function settle(type, value) {
      switch (type) {
        case "return":
          front.resolve({
            value: value,
            done: true
          });
          break;

        case "throw":
          front.reject(value);
          break;

        default:
          front.resolve({
            value: value,
            done: false
          });
          break;
      }

      front = front.next;

      if (front) {
        resume(front.key, front.arg);
      } else {
        back = null;
      }
    }

    this._invoke = send;

    if (typeof gen.return !== "function") {
      this.return = undefined;
    }
  }

  if (typeof Symbol === "function" && Symbol.asyncIterator) {
    AsyncGenerator.prototype[Symbol.asyncIterator] = function () {
      return this;
    };
  }

  AsyncGenerator.prototype.next = function (arg) {
    return this._invoke("next", arg);
  };

  AsyncGenerator.prototype.throw = function (arg) {
    return this._invoke("throw", arg);
  };

  AsyncGenerator.prototype.return = function (arg) {
    return this._invoke("return", arg);
  };

  return {
    wrap: function (fn) {
      return function () {
        return new AsyncGenerator(fn.apply(this, arguments));
      };
    },
    await: function (value) {
      return new AwaitValue(value);
    }
  };
}();















var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};











var objectWithoutProperties = function (obj, keys) {
  var target = {};

  for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue;
    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
    target[i] = obj[i];
  }

  return target;
};





var set = function set(object, property, value, receiver) {
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent !== null) {
      set(parent, property, value, receiver);
    }
  } else if ("value" in desc && desc.writable) {
    desc.value = value;
  } else {
    var setter = desc.set;

    if (setter !== undefined) {
      setter.call(receiver, value);
    }
  }

  return value;
};

var slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();

function ssml$1(tagName, props) {
  for (var _len = arguments.length, children = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    children[_key - 2] = arguments[_key];
  }

  var tag = throwIfUndefined(getTagDefinition(tagName), 'Unsupported tag: "' + tagName + '"');

  var hasProps = props || tag.defaultProps || children.length;
  var mergedProps = hasProps && _extends({}, tag.defaultProps, props, children.length && { children: children });
  var validatedProps = validate(tag, mergedProps);

  return _extends({ type: tag.type }, validatedProps && { props: validatedProps });
}

function throwIfUndefined(item, error) {
  if (!item) {
    throw new Error(error);
  } else {
    return item;
  }
}

function getTagDefinition(tag) {
  switch (typeof tag === 'undefined' ? 'undefined' : _typeof(tag)) {
    case 'string':
      return schema[tag];
    case 'function':
      return _extends({}, tag, { type: tag });
    default:
      return undefined;
  }
}

var entries = function entries(object) {
  return Object.keys(object).map(function (key) {
    return [key, object[key]];
  });
};

function renderToString(node) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (!node || node.type !== 'speak') {
    throw Error('Expected SSML to be surrounded in a <speak> tag.');
  }

  return render(node, _extends({}, options, { root: true }));
}

function render(node) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (!node) {
    return '';
  }

  if (Array.isArray(node)) {
    return node.map(function (child) {
      return render(child, _extends({}, options, { root: false }));
    }).join('');
  }

  if (typeof node.type === 'function') {
    return render(node.type(node.props), _extends({}, options, { root: false }));
  }

  if (typeof node === 'string') {
    return node;
  }

  var _ref = node.props || {},
      _ref$children = _ref.children,
      children = _ref$children === undefined ? [] : _ref$children,
      rest = objectWithoutProperties(_ref, ['children']);

  if (node.type === 'speak' && !options.root) {
    return children.map(function (child) {
      return render(child, _extends({}, options, { root: false }));
    }).join('');
  }

  var props = entries(rest).reduce(function (state, _ref2) {
    var _ref3 = slicedToArray(_ref2, 2),
        key = _ref3[0],
        value = _ref3[1];

    return state + ' ' + key + '="' + value + '"';
  }, '');

  return children.length ? '<' + node.type + props + '>' + children.map(function (child) {
    return render(child, _extends({}, options, { root: false }));
  }).join('') + '</' + node.type + '>' : '<' + node.type + props + '/>';
}

exports['default'] = ssml$1;
exports.renderToString = renderToString;
