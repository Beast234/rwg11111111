'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var AlexaRequest = function () {
  function AlexaRequest(_ref) {
    var session = _ref.session,
        request = _ref.request;

    _classCallCheck(this, AlexaRequest);

    this.session = session;
    this.request = request;
  }

  // returns the sessionId


  _createClass(AlexaRequest, [{
    key: 'getSessionId',
    value: function getSessionId() {
      return this.session.sessionId;
    }

    // returns the userId

  }, {
    key: 'getUserId',
    value: function getUserId() {
      return this.session.user.userId;
    }

    // returns the user access token

  }, {
    key: 'getUserAccessToken',
    value: function getUserAccessToken() {
      return this.session.user.accessToken;
    }

    // returns the user access token

  }, {
    key: 'getTimeStamp',
    value: function getTimeStamp() {
      return new Date((this.request.timestamp || '').replace(/-/g, '/').replace(/[TZ]/g, ' '));
    }

    // returns the request type

  }, {
    key: 'getRequestType',
    value: function getRequestType() {
      return this.request.type;
    }

    // returns the name of the intent

  }, {
    key: 'getIntentName',
    value: function getIntentName() {
      if (this.getRequestType() === 'IntentRequest') {
        return this.request.intent.name;
      }

      return this.getRequestType();
    }

    // will return the value of a slot if it exists

  }, {
    key: 'getSlotValue',
    value: function getSlotValue(slot) {
      var aSlot = this.request.intent.slots[slot];
      if (!aSlot) {
        throw new Error('Invalid slot ' + slot + '. Unable to find the slot in the request.');
      }

      return aSlot.value;
    }

    // validates that the request has the correct applicationId

  }, {
    key: 'verifyAppId',
    value: function verifyAppId(id) {
      return this.session.application.applicationId === id;
    }
  }]);

  return AlexaRequest;
}();

exports.default = AlexaRequest;
module.exports = exports['default'];